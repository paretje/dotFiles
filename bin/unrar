#!/bin/bash
# Unrar implementation using unar and unrar-free, supporting UNRAR 3.0 files
# Copyright: Â© 2014 Paretje
# Website: http://www.Online-Urbanus.be
# Last modified: 11/08/2014 by Paretje

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# It seems like unrar-free doesn't create a directory when multiple files
# are extracted
OPTS=''
DIR='-D'
OUT='stdout'

# Interpret basic commands
# Note: e and x do exactly the same thing now
case "$1" in
	'e' )	shift
		;;
	'l' )	unrar-free $@
		exit $?
		;;
	'v')	unrar-free $@
		exit $?
		;;
	'x')	shift
		;;
esac

# Handle options
if [ "$1" = '-ep' ]; then
	echo "Error: There doesn't seem to be an equivalent of -ep in unar." >&2
	exit 255
fi
if [ "${1:0:2}" = '-p' ]; then
	OPTS="$OPTS -p ${1:2}"
	shift
fi
if [ "$1" = '-u' ]; then
	OPTS="$OPTS -f"
	shift
fi

while [ "${1:0:1}" = '-' ]; do
	case "$1" in
		'--' )	shift
			break
			;;
		'-ad')	DIR='-d'
			shift
			;;
		'-ierr')OUT='stderr'
			shift
			;;
		'-inul')OUT='null'
			shift
			;;
		'-kb' )	shift # Default behaviour unar
			;;
		'-o-' )	OPTS="$OPTS -s"
			shift
			;;
		'-o+' )	OPTS="$OPTS -f"
			shift
			;;
		'-u' )	OPTS="$OPTS -f"
			echo "Warning: There doesn't seem to be an equivalent of -u in unar. All files will be overwritten." >&2
			shift
			;;
		* )	echo "Error: There doesn't seem to be an equivalent of $1 in unar. unrar will continue ignoring this option"
			shift
			;;
	esac
done

# Get filename
FILE="$1"
shift

# unar extracts files in the current working directory, unrar in the
# directory containing the file. We should force this behaviour.
OPTS="$DIR $OPTS -o $(dirname $FILE)"

if [ $OUT = 'stderr' ]; then
	unar $OPTS $FILE >&2
elif [ $OUT = 'null' ]; then
	unar $OPTS $FILE > /dev/null
else
	unar $OPTS $FILE
fi
